{"componentChunkName":"component---src-templates-blog-post-js","path":"/cpp-reflection-part-1/","result":{"data":{"site":{"siteMetadata":{"title":"Austin Brunkhorst","author":"Austin Brunkhorst"}},"markdownRemark":{"id":"05aeb3cd-9a7b-5f69-a463-0b6826d68463","excerpt":"Preface I set out this summer (2015) to implement a flexible reflection system for the game project I’m working on. This repository contains a skeleton for…","html":"<h2>Preface</h2>\n<p>I set out this summer (<em>2015</em>) to implement a flexible reflection system for the game project I’m working on. This repository contains a skeleton for parts of the system that I prototyped throughout the summer. With the proper dependencies and build system setup, you should have enough to integrate into your engine / application without much fuss.</p>\n<h2>Quick Intro</h2>\n<p>As a statically typed language, C++ wasn’t designed to facilitate runtime type information. Instead, it’s crazy fast and optimization friendly. Games are performance critical applications - it is for this reason that C++ is basically the standard backend.</p>\n<p>Type introspection is crucial for complex / large code bases that need to interface with tools (<em>i.e. a game editor</em>). Unless you’re a team of all programmers (<em>I’m sorry if that’s the case</em>) it is effectively impossible to iterate upon a larger game without some set of tools to abstract away code (<em>especially in 3D</em>). Without type introspection, you can expect to copy and paste a lot of boilerplate code. This is <strong>absurdly</strong> tedious and undesirable.</p>\n<p>The good news is that there are <em>tons and tons</em> of great resources out there for “extending” C++ to include meta information within your code base. The most common approaches you’ll find are as follows:</p>\n<ul>\n<li>Using macros and templates to simplify the craziness that is writing the aforementioned boilerplate code.</li>\n<li>Parsing your code to <strong>generate</strong> the crazy boilerplate code.</li>\n</ul>\n<p>The latter technique isn’t adopted nearly as much as the former, but feels like it’s becoming much more common. With that said, I chose to use the generation technique. I’m pretty glad I did.</p>\n<p>The purpose of this repository is to be a simple jumpstart reference for those interested in implementing the generation method in their own code base.</p>\n<p>Here are a few links that cover more specifics on the concept (<em>specifically in the realm of C/C++</em>)</p>\n<ul>\n<li><a href=\"http://www.gdcvault.com/play/1020065/Physics-for-Game-Programmers-Debugging\">GDC: Physics for Game Programmers - Debugging</a> (<em>it’s relevant, I swear!</em>)</li>\n<li><a href=\"http://www.gdcvault.com/play/1015586/\">GDC: Robustification Through Introspection and Analysis Tools (Avoiding Developer Taxes)</a></li>\n<li><a href=\"http://www.myopictopics.com/?p=368\">Game Engine Metadata Creation with Clang</a></li>\n<li><a href=\"http://eli.thegreenplace.net/2011/07/03/parsing-c-in-python-with-clang/\">Parsing C++ in Python with Clang</a></li>\n</ul>\n<h2>Goals</h2>\n<h5>Make the pipeline as hands off as possible.</h5>\n<p>Specifically, you shouldn’t have to jump through a bunch of hoops just to expose your code to the reflection runtime library. Make changes to your code, recompile, and the changes are reflected immediately (<em>yep, it was intended</em>).</p>\n<p>No extra button clicks or steps to synchronize the reflection data.</p>\n<h5>Provide rich functionality in the runtime library.</h5>\n<p>If we’re going through all this trouble in the first place, might as well make it worth while!</p>\n<h5>Avoid huge build times.</h5>\n<p>We’re effectively compiling our code twice. First to parse our code base and understand it as intricately as a compiler does, then to <em>actually</em> compile it as per usual (<em>with the addition of our generated source</em>).</p>\n<p>This is one of the downsides to the generation approach. Instead of manually writing these macros inline with our source, we’re using the brains of a compiler. However, we would much rather sacrifice a little bit shorter build times for the luxury of cleaner, less cluttered code.</p>\n<p>Unfortunately, this also implies creating a much less intuitive build pipeline. Don’t worry though! I have some nifty diagrams for you.</p>\n<h2>Pipeline</h2>\n<p>In our engine (<em>we call it <strong>Ursine Engine</strong>, because we’re dangerously clever and played on the fact that our team name is Bear King</em>), we use <a href=\"http://www.cmake.org/\">CMake</a> for managing most aspects of the overall build pipeline. CMake is a horribly wonderful tool that I’ve come to love despite hating it at the same time. It allows us to generate solutions for most IDEs that anyone on the team likes to use, although currently, everyone is using Visual Studio 2015 (<em>finally <strong>some</strong> C++14, baby!</em>).</p>\n<p>CMake makes this pipeline surprisingly simple which was a relief. I won’t go into much specific detail, but I’ll provide relevant snippets of the integration into our engine a little later when I describe the code in this repository.</p>\n<p>Here’s a diagram of the entire pipeline from writing the source, to building your game / application.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4f956dbf0b428167727711f19d32ff23/cecac/diagram.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 406.45604395604397%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAABRCAYAAADSHIbSAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAFdUlEQVRYw71YyY7jOAzN//9aAXXqPsyhMOilqrPHjjctdjR8tKjIjuyoqoExQMh2rJfHRSSljfPX7XbjURvr9sfS7Q4Fy3YPuXgpwvvyWjvVdU4pRaNyfd8zxmYO2LTK/dldxokEcjiV7kB/cKRxfywC8P54cdW1dE3TsGit3TAMj4Btp92f/Qj4sT27128/3Ld/frvX7z/cv7/2zB6gp/OV2HUMJGC4VgEx8ef70f36OPH4sTuH9+dL5ay1o5CZVlTWPEFsBUZ3VUcB83NR85xYFhliAuzIk4kVGBdl4zr6rVOa7yEyL0gKECNAL2XNLKqGvEggS1c8b6Jy/GP8DNtorUgMGx4eLYrSlWXJv8Vgbomh3AtAXdcscMDb25t7eXlxr6+vrm3bZcAlUAF+prJcmzWbYBV0tBqgHtjgPqVmDLoIiInH43Ei+/2eQb8MeDqdGOj99zuD4T4GTF2rgIfDgQVgGHe7XZJhtg1lncJ+8zX7lOF8CWEiWELgHLmfAy56ef4BJkI9SFM3PIIpYjFb5XnsySRRlZ9plPsshvhYEQDUs6IyPXOawjP9ro1xJmK6CigA/M7L/B7AAP00IGzGQU3xeKCxoBWDr8DOfAWQLOUGn+du/DxeANSiRZYNESYIGy9iyz6yoc2xYfCc96SI9k6S56VQSzIUtaXocK0mwHnAZ4cNPjY+RMrr1V2KgjJ0MY7kFEXqQu3YKasMwQD2wVg3VFOqylV15cea/6z336wCzll2VEO0Jbb9wPcG9yTK2DtYnlPG0Q4k/cCCfkfubVh2Cwl2XkdEQldAIr2LPMcZJ8lw/hITjI+5K9uuYQdpcchKxtnErCRcwILbNAgxk3yI9ybBMJaJyggFCV5MHrOKca2mPtBSCrvBhv2E1aLK1q9P3A8+zrQdVWw0lVCjyAwImXQZxZ8FhpKOWsrKuO9EXaMZsDWdB++ZsdLjWgfrStXhj7jhjD3a+aQgNgQIVOzMqDLuMRl/NI7K1aoJv4HlZt4Yha5Be4b00bWr2I7CsKXOFQAAK9or/2YHe2cooSI5LtjVq4LJfSTzCjnx8p2RZhsqX387dWcoNrQe/GmzJE6R4iS1WJzS6Ia9DMZ25uVkHEqoyKK/pzHDJYDZ+ZUDw2fV5WGW4yKdnvaED0sPzGpKAMh3UoOXVFpqSgOgZGhuNUhgy2EhvedcD8lB1PwK2IMN41p7+yLLYMM2UnnJhjl/sJE811DbgcysopI592yOYyY2NJ7dXIJtM0Jns8QgLvZYNdITrvWGDwxjB3E8EiB2UKgnEHkHTRY7h6UtGTvHd2IdpSskC+ko1triTcrw9/w4hNYkbuLX7LhZ8iQ3SS1l5Io2jm3HRd5Y+9DGZe/14stGNnv2bbK3kcxjfMjAfhJCJgr87IZTOgQkCbRwELRzAJaWOLUrXWfoPQpGXAHJ28HLK45J9of3frr3RwS+Jb4Nk4YpFXLJDrZuKlLxQuWyYXbjGlcsiMmmbXhMlYPkXs9QcUL3qq326o9dw7iubWicspr2YbaXYyeg1qRywc09Xylhr0wgvBOltIb+GjUHquq45iRAk2EjaxmAdT0CoYABVDaOWStluo77oHrcN8434V9eeguHNvlLj/tFsh/UvPo9Su1LBCeIW2b6mgDCKf4Es5aTzNy1nGNDeb9aAnJsaBLpK5th/CE2jefzmU+YLpfLw8nSpxhCRTmq2m634YQpdcT3/wHOV0vh98oiUF/5JPtphpPAjjrb7M7hITkoHY7mEX9QVfZ/awdqi4A47JYTOXiWSwASg4/Jv4tDa/5e5dA0+d1B77decf7LYjgJHQLAxmd/PdJepRtPmZ40nptnp+cArHiDaMIW9rbSg/8HtDr7H+hy7ZMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Pipeline Diagram\"\n        title=\"Pipeline Diagram\"\n        src=\"/static/4f956dbf0b428167727711f19d32ff23/fcda8/diagram.png\"\n        srcset=\"/static/4f956dbf0b428167727711f19d32ff23/12f09/diagram.png 148w,\n/static/4f956dbf0b428167727711f19d32ff23/e4a3f/diagram.png 295w,\n/static/4f956dbf0b428167727711f19d32ff23/fcda8/diagram.png 590w,\n/static/4f956dbf0b428167727711f19d32ff23/cecac/diagram.png 728w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>Code</h2>\n<p>The repository has two parts - <a href=\"https://github.com/AustinBrunkhorst/CPP-Reflection/tree/master/Source/Parser\">Parser</a> and <a href=\"https://github.com/AustinBrunkhorst/CPP-Reflection/tree/master/Source/Runtime\">Runtime</a>.</p>\n<ul>\n<li><strong>Parser</strong> is for the command line source parsing tool. (requires <a href=\"http://www.boost.org/users/history/version_1_59_0.html\">Boost 1.59.0</a> and <a href=\"http://llvm.org/releases/download.html\">libclang 3.7.0</a>)</li>\n<li><strong>Runtime</strong> is for the reflection runtime library.</li>\n</ul>\n<h3>CMake Prebuild Example</h3>\n<p>This is basic example of adding the prebuild step to an existing target in CMake.</p>\n<div class=\"gatsby-highlight\" data-language=\"cmake\"><pre class=\"language-cmake\"><code class=\"language-cmake\"><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span><span class=\"token variable\">PROJECT_NAME</span> <span class=\"token string\">\"Example\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># assume this contains header files for this project</span>\n<span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>PROJECT_HEADER_FILES ...<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># assume this contains source files for this project</span>\n<span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>PROJECT_SOURCE_FILES ...<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># generated file names, in the build directory</span>\n<span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>META_GENERATED_HEADER <span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token punctuation\">${</span><span class=\"token variable\">CMAKE_CURRENT_BINARY_DIR</span><span class=\"token punctuation\">}</span></span>/Meta.Generated.h\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>META_GENERATED_SOURCE <span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token punctuation\">${</span><span class=\"token variable\">CMAKE_CURRENT_BINARY_DIR</span><span class=\"token punctuation\">}</span></span>/Meta.Generated.cpp\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># create the project target</span>\n<span class=\"token keyword\">add_executable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">${</span><span class=\"token variable\">PROJECT_NAME</span><span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">${</span>PROJECT_HEADER_FILES<span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">${</span>PROJECT_SOURCE_FILES<span class=\"token punctuation\">}</span>\n    <span class=\"token comment\"># make sure the generated header and source are included</span>\n    <span class=\"token punctuation\">${</span>META_GENERATED_HEADER<span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">${</span>META_GENERATED_SOURCE<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># path to the reflection parser executable</span>\n<span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>PARSE_TOOL_EXE <span class=\"token string\">\"ReflectionParser.exe\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># input source file to pass to the reflection parser compiler</span>\n<span class=\"token comment\"># in this file, include any files that you want exposed to the parser</span>\n<span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>PROJECT_META_HEADER <span class=\"token string\">\"Reflection.h\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># fetch all include directories for the project target</span>\n<span class=\"token keyword\">get_property</span><span class=\"token punctuation\">(</span>DIRECTORIES TARGET <span class=\"token punctuation\">${</span><span class=\"token variable\">PROJECT_NAME</span><span class=\"token punctuation\">}</span> PROPERTY <span class=\"token property\">INCLUDE_DIRECTORIES</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># flags that will eventually be based to the reflection parser compiler</span>\n<span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>META_FLAGS <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># build the include directory flags</span>\n<span class=\"token keyword\">foreach</span> <span class=\"token punctuation\">(</span>DIRECTORY <span class=\"token punctuation\">${</span>DIRECTORIES<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>META_FLAGS <span class=\"token punctuation\">${</span>meta_flags<span class=\"token punctuation\">}</span> <span class=\"token string\">\"\\\\\\\\-I<span class=\"token interpolation\"><span class=\"token punctuation\">${</span><span class=\"token variable\">DIRECTORY</span><span class=\"token punctuation\">}</span></span>\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">endforeach</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># include the system directories</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token variable\">MSVC</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># assume ${VS_VERSION} is the version of Visual Studio being used to compile</span>\n    <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>META_FLAGS <span class=\"token punctuation\">${</span>META_FLAGS<span class=\"token punctuation\">}</span>\n        <span class=\"token string\">\"\\\\\\\\-IC:/Program Files (x86)/Microsoft Visual Studio <span class=\"token interpolation\"><span class=\"token punctuation\">${</span><span class=\"token variable\">VS_VERSION</span><span class=\"token punctuation\">}</span></span>/VC/include\"</span>\n    <span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">else</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># you can figure it out for other compilers :)</span>\n    <span class=\"token keyword\">message</span><span class=\"token punctuation\">(</span>FATAL_ERROR <span class=\"token string\">\"System include directories not implemented for this compiler.\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">endif</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># add the command that invokes the reflection parser executable</span>\n<span class=\"token comment\"># whenever a header file in your project has changed</span>\n<span class=\"token keyword\">add_custom_command</span><span class=\"token punctuation\">(</span>\n    OUTPUT <span class=\"token punctuation\">${</span>META_GENERATED_HEADER<span class=\"token punctuation\">}</span> <span class=\"token punctuation\">${</span>META_GENERATED_SOURCE<span class=\"token punctuation\">}</span>\n    <span class=\"token property\">DEPENDS</span> <span class=\"token punctuation\">${</span>PROJECT_HEADER_FILES<span class=\"token punctuation\">}</span>\n    COMMAND call <span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token punctuation\">${</span><span class=\"token variable\">PARSE_TOOL_EXE</span><span class=\"token punctuation\">}</span></span>\"</span>\n    --target-name <span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token punctuation\">${</span><span class=\"token variable\">PROJECT_NAME</span><span class=\"token punctuation\">}</span></span>\"</span>\n    --in-source <span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token punctuation\">${</span><span class=\"token variable\">CMAKE_CURRENT_SOURCE_DIR</span><span class=\"token punctuation\">}</span></span>/<span class=\"token interpolation\"><span class=\"token punctuation\">${</span><span class=\"token variable\">PROJECT_SOURCE_DIR</span><span class=\"token punctuation\">}</span></span>/<span class=\"token interpolation\"><span class=\"token punctuation\">${</span><span class=\"token variable\">PROJECT_META_HEADER</span><span class=\"token punctuation\">}</span></span>\"</span>\n    --out-header <span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token punctuation\">${</span><span class=\"token variable\">META_GENERATED_HEADER</span><span class=\"token punctuation\">}</span></span>\"</span>\n    --out-source <span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token punctuation\">${</span><span class=\"token variable\">META_GENERATED_SOURCE</span><span class=\"token punctuation\">}</span></span>\"</span>\n    --flags <span class=\"token punctuation\">${</span>META_FLAGS<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<h3>String Templates</h3>\n<p>Generating code is usually a pretty ugly process.</p>\n<p>Instead of writing the characters manually (i.e. <code class=\"language-text\">output += &quot;REGISTER_FUNCTION(&quot; + name + &quot;)&quot;</code> ), I wanted to use <em>“String Templates”</em>. That is why I chose <a href=\"https://mustache.github.io/\">Mustache</a>. I found a simple <a href=\"https://github.com/kainjow/Mustache\">header only implemenation</a>, which is included in the <a href=\"https://github.com/AustinBrunkhorst/CPP-Reflection/blob/master/Source/Parser/Mustache.h\">Parser</a> section.</p>\n<p>In the <strong>Generate Source Files</strong> section of the pipeline diagram, you’ll notice two steps. <em>“Compile”</em> and <em>“Render”</em>. Compile simply takes all of the types that we’ve extracted and <a href=\"https://github.com/AustinBrunkhorst/CPP-Reflection/blob/master/Source/Parser/ReflectionParser.cpp#L217-L220\">compiles the data to be referenced in Mustache</a>. Render actually renders the templates and writes them to the configured output files.</p>\n<p>In the <a href=\"https://github.com/AustinBrunkhorst/CPP-Reflection/tree/master/Templates\">Templates</a> folder of the repository, you’ll find the mustache template files referenced in the reflection parser.</p>\n<h3>Type Meta Data</h3>\n<p>One of the biggest features that I wanted to implement in the runtime library is being able to add meta data to types at compile time.</p>\n<p>If you’ve ever used C#, you know they have a pretty groovy reflection system built into the language. I really like their syntax for <a href=\"http://www.tutorialspoint.com/csharp/csharp_attributes.htm\">Attributes</a>, which is a way to add meta data to language types / constructs.</p>\n<p>The closest I could get to this style, was with the use of Macros. C++11 introduced <a href=\"http://en.cppreference.com/w/cpp/language/attributes\">Attribute Specifiers</a> as a way to hint compilers on intended behavior or add language extensions. Unfortunately, compiler support varies widely, and as mentioned it’s only managed at compile time.</p>\n<p>Luckily for us, Clang supports the attribute <code class=\"language-text\">annotate( )</code>. You can extract the contents of an annotation with <a href=\"https://github.com/AustinBrunkhorst/CPP-Reflection/blob/master/Source/Parser/MetaDataManager.cpp#L10-L17\">libclang</a>.</p>\n<p>The syntax for this attribute look something like this.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">__attribute__</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span> <span class=\"token function\">annotate</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"Hey look at this annotation!\"</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>You might be thinking, <em>“But it’s only for Clang.. how will this work in MSVC?”</em></p>\n<p>More good news! libclang preprocesses source files, so we can use preprocessor directives. In the source parsing tool, I define <code class=\"language-text\">__REFLECTION_PARSER__</code> <a href=\"https://github.com/AustinBrunkhorst/CPP-Reflection/blob/master/Source/Parser/Main.cpp#L126\">before compiling</a>. We can use this to make a nice solution for all compilers.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">if</span> defined(__REFLECTION_PARSER__)</span>\n<span class=\"token macro property\">#   <span class=\"token directive keyword\">define</span> Meta(...) __attribute__((annotate(#__VA_ARGS__)))</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">else</span></span>\n<span class=\"token macro property\">#   <span class=\"token directive keyword\">define</span> Meta(...)</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span></code></pre></div>\n<p>We would use it like so.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">Meta</span><span class=\"token punctuation\">(</span>Mashed<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">int</span> potatoes<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Now that I could annotate code, I needed to define how I would interact with it. Initially I assumed key value pairs separated by commas, like so.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">Meta</span><span class=\"token punctuation\">(</span>Key <span class=\"token operator\">=</span> Value<span class=\"token punctuation\">,</span> Key2<span class=\"token punctuation\">,</span> Key <span class=\"token operator\">=</span> <span class=\"token string\">\"Yep!\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>But after reviewing this approach with my teammate <a href=\"https://www.linkedin.com/in/jordancellis/\">Jordan</a>, he came up with the brilliant idea of doing exactly what C# does, and that is using user defined types as annotations, queryable at runtime. So I came up with this.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Mashed</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> MetaProperty <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">Meta</span><span class=\"token punctuation\">(</span>Mashed<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">int</span> potatoes<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Here’s how it works - I treat all values delimited by commas as constructors. If a value doesn’t have parentheses, it’s assumed to be a default constructor.</p>\n<p>For each constructor, I then extract the arguments provided. When I generate the source, I simply paste the extracted arguments as a constructor call of the provided type. The value is converted to a <code class=\"language-text\">Variant</code> and accessible at runtime. This allows us to do some really awesome things.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">enum</span> <span class=\"token class-name\">class</span> SliderType\n<span class=\"token punctuation\">{</span>\n    Horizontal<span class=\"token punctuation\">,</span>\n    Vertical\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Slider</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> MetaProperty\n<span class=\"token punctuation\">{</span>\n    SliderType type<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">Slider</span><span class=\"token punctuation\">(</span>SliderType type<span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">:</span> <span class=\"token function\">type</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Range</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> MetaProperty\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">float</span> min<span class=\"token punctuation\">,</span> max<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">Range</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> min<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> max<span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">:</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">,</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">Meta</span><span class=\"token punctuation\">(</span><span class=\"token function\">Range</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">Slider</span><span class=\"token punctuation\">(</span>SliderType<span class=\"token operator\">::</span>Horizontal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">float</span> someIntensityField<span class=\"token punctuation\">;</span></code></pre></div>\n<p>One of the coolest things about this, aside from type safety, is that Visual Studio correctly syntax highlights the contents of the macro and also provides intellisense! It’s a beautiful thing. Here’s a more complete example of interfacing with it at runtime using the runtime library.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">SoundEffect</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Meta</span><span class=\"token punctuation\">(</span><span class=\"token function\">Range</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">float</span> volume<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// you can also use type meta::Type::Get( \"SoundEffect\" ) based on a string name</span>\n    Type soundEffectType <span class=\"token operator\">=</span> <span class=\"token function\">typeof</span><span class=\"token punctuation\">(</span> SoundEffect <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// the volume field in the SoundEffect struct</span>\n    Field volumeField <span class=\"token operator\">=</span> soundEffectType<span class=\"token punctuation\">.</span><span class=\"token function\">GetField</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"volume\"</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// meta data for the volume field</span>\n    MetaManager <span class=\"token operator\">&amp;</span>volumeMeta <span class=\"token operator\">=</span> volumeField<span class=\"token punctuation\">.</span><span class=\"token function\">GetMeta</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// getting the \"Range\" property, then casting the variant as a range</span>\n    Range volumeRange <span class=\"token operator\">=</span> volumeMeta<span class=\"token punctuation\">.</span><span class=\"token function\">GetProperty</span><span class=\"token punctuation\">(</span> <span class=\"token function\">typeof</span><span class=\"token punctuation\">(</span> Range <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">GetValue</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 0.0f</span>\n    <span class=\"token keyword\">float</span> min <span class=\"token operator\">=</span> volumeRange<span class=\"token punctuation\">.</span>min<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 100.0f</span>\n    <span class=\"token keyword\">float</span> max <span class=\"token operator\">=</span> volumeRange<span class=\"token punctuation\">.</span>max<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Function Binding</h3>\n<p>Another notoriously difficult or convoluted process in managing reflection info in C++ is dynamically invoking functions / methods.</p>\n<p>The most common approach is to store raw function / method pointers and calculate the offsets of arguments. The result is a ton of templates and difficult to follow operations. Not to mention, I can’t imagine it’s fun to debug!</p>\n<p>In libclang, you’re able to easily extract signatures from functions. With this in mind, I came up with the most simple approach that I could think of. <strong>Wrapping function calls in generated lambdas</strong>.</p>\n<p>Here’s a simple demonstration of the concept.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> c<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">auto</span> fooWrapper <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> c<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// same behavior as foo(0, 1.0f, 2.0);</span>\n<span class=\"token function\">fooWrapper</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>In the context of our runtime library, here’s an example of something that might be generated for a class method.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">DemoClass</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">someMethod</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">auto</span> someMethodWrapper <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>Variant <span class=\"token operator\">&amp;</span>obj<span class=\"token punctuation\">,</span> ArgumentList <span class=\"token operator\">&amp;</span>args<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>instance <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">.</span><span class=\"token function\">GetValue</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> Variant <span class=\"token punctuation\">{</span>\n        instance<span class=\"token punctuation\">.</span><span class=\"token function\">someMethod</span><span class=\"token punctuation\">(</span>\n            args<span class=\"token punctuation\">[</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">GetValue</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>That’s it! It’s much less complicated than the previously mentioned approach. This concept is also applied to fields / globals with their getters and setters.</p>\n<p>There are some downsides though:</p>\n<ul>\n<li>Larger code size. For each generated lambda, the compiler has to generate a bunch of symbols behind the scenes.</li>\n<li>Larger compile times.</li>\n<li>Decent amount of indirection just for one function call.</li>\n</ul>\n<p>You shouldn’t have to worry <strong>too</strong> much however. If like most people, you use reflection for editor functionality, not a physics simulation. Performance in most cases is not critical.</p>\n<p>Here’s a more complete example of dynamically calling functions with the runtime library.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">SoundEffect</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">float</span> volume<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token operator\">::</span>string <span class=\"token operator\">&amp;</span>filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Type soundEffectType <span class=\"token operator\">=</span> <span class=\"token function\">typeof</span><span class=\"token punctuation\">(</span> SoundEffect <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Field volumeField <span class=\"token operator\">=</span> soundEffectType<span class=\"token punctuation\">.</span><span class=\"token function\">GetField</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"volume\"</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// the runtime supports overloading, but by default returns the first overload</span>\n    Method loadMethod <span class=\"token operator\">=</span> soundEffectType<span class=\"token punctuation\">.</span><span class=\"token function\">GetMethod</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"Load\"</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// creates an instance of a sound effect</span>\n    Variant effect <span class=\"token operator\">=</span> soundEffectType<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// effect.volume is now 85</span>\n    volumeField<span class=\"token punctuation\">.</span><span class=\"token function\">SetValue</span><span class=\"token punctuation\">(</span> effect<span class=\"token punctuation\">,</span> <span class=\"token number\">85.0f</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 85</span>\n    volumeField<span class=\"token punctuation\">.</span><span class=\"token function\">GetValue</span><span class=\"token punctuation\">(</span> effect <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// effect.Load is called</span>\n    loadMethod<span class=\"token punctuation\">.</span><span class=\"token function\">Invoke</span><span class=\"token punctuation\">(</span> effect<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>string <span class=\"token punctuation\">{</span> <span class=\"token string\">\"Explosion.wav\"</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"title":"C++ Reflection","date":"June 16, 2016","description":"Turn your code into more code."}}},"pageContext":{"slug":"/cpp-reflection-part-1/","previous":null,"next":null}}}