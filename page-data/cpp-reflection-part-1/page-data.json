{"componentChunkName":"component---node-modules-gatsby-theme-blog-src-templates-post-js","path":"/cpp-reflection-part-1","webpackCompilationHash":"d783dd221eeedb5b0895","result":{"data":{"post":{"id":"b0bfa1d0-ce5c-543d-abfc-9a88cdd60bfb","title":"C++ Reflection","date":"June 16, 2019","excerpt":"Back in September ( 2015 ), I did a little write-up on my experiences and approach to building a complete reflection pipeline in C++. At…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"C++ Reflection\",\n  \"date\": \"2019-06-16T00:00:00.000Z\",\n  \"tags\": [\"c\", \"reflection\", \"meta\", \"introspection\", \"code-generation\", \"clang\", \"llvm\", \"game-development\", \"software\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Back in September (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2015\"), \"), I did a little write-up on my experiences and approach to building a complete reflection pipeline in C++. At that time, I didn\\u2019t have a blog setup, so I just included the details in the README of the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/AustinBrunkhorst/CPP-Reflection\"\n  }), \"GitHub repository\"), \" where the code lived.\"), mdx(\"p\", null, \"I have since refactored that code and the pipeline after using it extensively on my game team. The response from the community has been great enough that I decided to start a blog in general and continue the write-ups. The rest of this post is taken directly from the README, so any references to a repository are talking about \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/AustinBrunkhorst/CPP-Reflection\"\n  }), \"this\"), \".\"), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"preface\"\n  }, \"Preface\"), mdx(\"p\", null, \"I set out this summer (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2015\"), \") to implement a flexible reflection system for the game project I\\u2019m working on. This repository contains a skeleton for parts of the system that I prototyped throughout the summer. With the proper dependencies and build system setup, you should have enough to integrate into your engine / application without much fuss.\"), mdx(\"h2\", {\n    \"id\": \"quick-intro\"\n  }, \"Quick Intro\"), mdx(\"p\", null, \"As a statically typed language, C++ wasn\\u2019t designed to facilitate runtime type information. Instead, it\\u2019s crazy fast and optimization friendly. Games are performance critical applications - it is for this reason that C++ is basically the standard backend.\"), mdx(\"p\", null, \"Type introspection is crucial for complex / large code bases that need to interface with tools (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i.e. a game editor\"), \"). Unless you\\u2019re a team of all programmers (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"I\\u2019m sorry if that\\u2019s the case\"), \") it is effectively impossible to iterate upon a larger game without some set of tools to abstract away code (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"especially in 3D\"), \"). Without type introspection, you can expect to copy and paste a lot of boilerplate code. This is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"absurdly\"), \" tedious and undesirable.\"), mdx(\"p\", null, \"The good news is that there are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"tons and tons\"), \" of great resources out there for \\u201Cextending\\u201D C++ to include meta information within your code base. The most common approaches you\\u2019ll find are as follows:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using macros and templates to simplify the craziness that is writing the aforementioned boilerplate code.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Parsing your code to \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"generate\"), \" the crazy boilerplate code.\")), mdx(\"p\", null, \"The latter technique isn\\u2019t adopted nearly as much as the former, but feels like it\\u2019s becoming much more common. With that said, I chose to use the generation technique. I\\u2019m pretty glad I did.\"), mdx(\"p\", null, \"The purpose of this repository is to be a simple jumpstart reference for those interested in implementing the generation method in their own code base.\"), mdx(\"p\", null, \"Here are a few links that cover more specifics on the concept (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"specifically in the realm of C/C++\"), \")\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"http://www.gdcvault.com/play/1020065/Physics-for-Game-Programmers-Debugging\"\n  }), \"GDC: Physics for Game Programmers - Debugging\"), \" (\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"it\\u2019s relevant, I swear!\"), \")\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"http://www.gdcvault.com/play/1015586/\"\n  }), \"GDC: Robustification Through Introspection and Analysis Tools (Avoiding Developer Taxes)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"http://www.myopictopics.com/?p=368\"\n  }), \"Game Engine Metadata Creation with Clang\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"http://eli.thegreenplace.net/2011/07/03/parsing-c-in-python-with-clang/\"\n  }), \"Parsing C++ in Python with Clang\"))), mdx(\"h2\", {\n    \"id\": \"goals\"\n  }, \"Goals\"), mdx(\"h5\", {\n    \"id\": \"make-the-pipeline-as-hands-off-as-possible\"\n  }, \"Make the pipeline as hands off as possible.\"), mdx(\"p\", null, \"Specifically, you shouldn\\u2019t have to jump through a bunch of hoops just to expose your code to the reflection runtime library. Make changes to your code, recompile, and the changes are reflected immediately (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"yep, it was intended\"), \").\"), mdx(\"p\", null, \"No extra button clicks or steps to synchronize the reflection data.\"), mdx(\"h5\", {\n    \"id\": \"provide-rich-functionality-in-the-runtime-library\"\n  }, \"Provide rich functionality in the runtime library.\"), mdx(\"p\", null, \"If we\\u2019re going through all this trouble in the first place, might as well make it worth while!\"), mdx(\"h5\", {\n    \"id\": \"avoid-huge-build-times\"\n  }, \"Avoid huge build times.\"), mdx(\"p\", null, \"We\\u2019re effectively compiling our code twice. First to parse our code base and understand it as intricately as a compiler does, then to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"actually\"), \" compile it as per usual (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"with the addition of our generated source\"), \").\"), mdx(\"p\", null, \"This is one of the downsides to the generation approach. Instead of manually writing these macros inline with our source, we\\u2019re using the brains of a compiler. However, we would much rather sacrifice a little bit shorter build times for the luxury of cleaner, less cluttered code.\"), mdx(\"p\", null, \"Unfortunately, this also implies creating a much less intuitive build pipeline. Don\\u2019t worry though! I have some nifty diagrams for you.\"), mdx(\"h2\", {\n    \"id\": \"pipeline\"\n  }, \"Pipeline\"), mdx(\"p\", null, \"In our engine (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"we call it \", mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"Ursine Engine\"), \", because we\\u2019re dangerously clever and played on the fact that our team name is Bear King\"), \"), we use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.cmake.org/\"\n  }), \"CMake\"), \" for managing most aspects of the overall build pipeline. CMake is a horribly wonderful tool that I\\u2019ve come to love despite hating it at the same time. It allows us to generate solutions for most IDEs that anyone on the team likes to use, although currently, everyone is using Visual Studio 2015 (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"finally \", mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"some\"), \" C++14, baby!\"), \").\"), mdx(\"p\", null, \"CMake makes this pipeline surprisingly simple which was a relief. I won\\u2019t go into much specific detail, but I\\u2019ll provide relevant snippets of the integration into our engine a little later when I describe the code in this repository.\"), mdx(\"p\", null, \"Here\\u2019s a diagram of the entire pipeline from writing the source, to building your game / application.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://imgur.com/V7RLPAj.png\",\n    \"alt\": \"Pipeline Diagram\"\n  }))), mdx(\"h2\", {\n    \"id\": \"code\"\n  }, \"Code\"), mdx(\"p\", null, \"The repository has two parts - \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/AustinBrunkhorst/CPP-Reflection/tree/master/Source/Parser\"\n  }), \"Parser\"), \" and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/AustinBrunkhorst/CPP-Reflection/tree/master/Source/Runtime\"\n  }), \"Runtime\"), \".\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Parser\"), \" is for the command line source parsing tool. (\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"requires \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"http://www.boost.org/users/history/version_1_59_0.html\"\n  }), \"Boost 1.59.0\"), \" and \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"http://llvm.org/releases/download.html\"\n  }), \"libclang 3.7.0\")), \")\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Runtime\"), \" is for the reflection runtime library.\")), mdx(\"h3\", {\n    \"id\": \"cmake-prebuild-example\"\n  }, \"CMake Prebuild Example\"), mdx(\"p\", null, \"This is basic example of adding the prebuild step to an existing target in CMake.\"), mdx(\"script\", {\n    src: \"https://gist.github.com/AustinBrunkhorst/38a3ca236238604ee32ef58d2e9c6e90.js\"\n  }), mdx(\"h3\", {\n    \"id\": \"string-templates\"\n  }, \"String Templates\"), mdx(\"p\", null, \"Generating code is usually a pretty ugly process.\"), mdx(\"p\", null, \"Instead of writing the characters manually (i.e. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"output += \\\"REGISTER_FUNCTION(\\\" + name + \\\")\\\"\"), \" ), I wanted to use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\u201CString Templates\\u201D\"), \". That is why I chose \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://mustache.github.io/\"\n  }), \"Mustache\"), \". I found a simple \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/kainjow/Mustache\"\n  }), \"header only implemenation\"), \", which is included in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/AustinBrunkhorst/CPP-Reflection/blob/master/Source/Parser/Mustache.h\"\n  }), \"Parser\"), \" section.\"), mdx(\"p\", null, \"In the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Generate Source Files\"), \" section of the pipeline diagram, you\\u2019ll notice two steps. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\u201CCompile\\u201D\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\u201CRender\\u201D\"), \". Compile simply takes all of the types that we\\u2019ve extracted and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/AustinBrunkhorst/CPP-Reflection/blob/master/Source/Parser/ReflectionParser.cpp#L217-L220\"\n  }), \"compiles the data to be referenced in Mustache\"), \". Render actually renders the templates and writes them to the configured output files.\"), mdx(\"p\", null, \"In the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/AustinBrunkhorst/CPP-Reflection/tree/master/Templates\"\n  }), \"Templates\"), \" folder of the repository, you\\u2019ll find the mustache template files referenced in the reflection parser.\"), mdx(\"h3\", {\n    \"id\": \"type-meta-data\"\n  }, \"Type Meta Data\"), mdx(\"p\", null, \"One of the biggest features that I wanted to implement in the runtime library is being able to add meta data to types at compile time.\"), mdx(\"p\", null, \"If you\\u2019ve ever used C#, you know they have a pretty groovy reflection system built into the language. I really like their syntax for \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.tutorialspoint.com/csharp/csharp_attributes.htm\"\n  }), \"Attributes\"), \", which is a way to add meta data to language types / constructs.\"), mdx(\"p\", null, \"The closest I could get to this style, was with the use of Macros. C++11 introduced \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://en.cppreference.com/w/cpp/language/attributes\"\n  }), \"Attribute Specifiers\"), \" as a way to hint compilers on intended behavior or add language extensions. Unfortunately, compiler support varies widely, and as mentioned it\\u2019s only managed at compile time.\"), mdx(\"p\", null, \"Luckily for us, Clang supports the attribute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"annotate( )\"), \". You can extract the contents of an annotation with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/AustinBrunkhorst/CPP-Reflection/blob/master/Source/Parser/MetaDataManager.cpp#L10-L17\"\n  }), \"libclang\"), \".\"), mdx(\"p\", null, \"The syntax for this attribute look something like this.\"), mdx(\"script\", {\n    src: \"https://gist.github.com/AustinBrunkhorst/dda9ed424e1e831173c8c09edfdac426.js\"\n  }), mdx(\"p\", null, \"You might be thinking, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\u201CBut it\\u2019s only for Clang.. how will this work in MSVC?\\u201D\")), mdx(\"p\", null, \"More good news! libclang preprocesses source files, so we can use preprocessor directives. In the source parsing tool, I define \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__REFLECTION_PARSER__\"), \" \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/AustinBrunkhorst/CPP-Reflection/blob/master/Source/Parser/Main.cpp#L126\"\n  }), \"before compiling\"), \". We can use this to make a nice solution for all compilers.\"), mdx(\"script\", {\n    src: \"https://gist.github.com/AustinBrunkhorst/11ce4da2354f152e141a1d19fa54ca57.js\"\n  }), mdx(\"p\", null, \"We would use it like so.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"Meta(Mashed)\\nint potatoes;\\n\")), mdx(\"p\", null, \"Now that I could annotate code, I needed to define how I would interact with it. Initially I assumed key value pairs separated by commas, like so.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"Meta(Key = Value, Key2, Key = \\\"Yep!\\\")\\n\")), mdx(\"p\", null, \"But after reviewing this approach with my teammate \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.jordanellis.me\"\n  }), \"Jordan\"), \", he came up with the brilliant idea of doing exactly what C# does, and that is using user defined types as annotations, queryable at runtime. So I came up with this.\"), mdx(\"script\", {\n    src: \"https://gist.github.com/AustinBrunkhorst/e30ce39836692ae138a8afdaf884d220.js\"\n  }), mdx(\"p\", null, \"Here\\u2019s how it works - I treat all values delimited by commas as constructors. If a value doesn\\u2019t have parentheses, it\\u2019s assumed to be a default constructor.\"), mdx(\"p\", null, \"For each constructor, I then extract the arguments provided. When I generate the source, I simply paste the extracted arguments as a constructor call of the provided type. The value is converted to a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Variant\"), \" and accessible at runtime. This allows us to do some really awesome things.\"), mdx(\"script\", {\n    src: \"https://gist.github.com/AustinBrunkhorst/9f40e50eebceecb040d1b53318909909.js\"\n  }), mdx(\"p\", null, \"One of the coolest things about this, aside from type safety, is that Visual Studio correctly syntax highlights the contents of the macro and also provides intellisense! It\\u2019s a beautiful thing. Here\\u2019s a more complete example of interfacing with it at runtime using the runtime library.\"), mdx(\"script\", {\n    src: \"https://gist.github.com/AustinBrunkhorst/94973cf89c572f6b007a572253a49f70.js\"\n  }), mdx(\"h3\", {\n    \"id\": \"function-binding\"\n  }, \"Function Binding\"), mdx(\"p\", null, \"Another notoriously difficult or convoluted process in managing reflection info in C++ is dynamically invoking functions / methods.\"), mdx(\"p\", null, \"The most common approach is to store raw function / method pointers and calculate the offsets of arguments. The result is a ton of templates and difficult to follow operations. Not to mention, I can\\u2019t imagine it\\u2019s fun to debug!\"), mdx(\"p\", null, \"In libclang, you\\u2019re able to easily extract signatures from functions. With this in mind, I came up with the most simple approach that I could think of. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Wrapping function calls in generated lambdas\"), \".\"), mdx(\"p\", null, \"Here\\u2019s a simple demonstration of the concept.\"), mdx(\"script\", {\n    src: \"https://gist.github.com/AustinBrunkhorst/be5031e4c101c7051f10a5c05a72bbf1.js\"\n  }), mdx(\"p\", null, \"In the context of our runtime library, here\\u2019s an example of something that might be generated for a class method.\"), mdx(\"script\", {\n    src: \"https://gist.github.com/AustinBrunkhorst/ee94408f4ab0368777a5e868627f13c8.js\"\n  }), mdx(\"p\", null, \"That\\u2019s it! It\\u2019s much less complicated than the previously mentioned approach. This concept is also applied to fields / globals with their getters and setters.\"), mdx(\"p\", null, \"There are some downsides though:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Larger code size. For each generated lambda, the compiler has to generate a bunch of symbols behind the scenes.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Larger compile times.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Decent amount of indirection just for one function call.\")), mdx(\"p\", null, \"You shouldn\\u2019t have to worry \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"too\"), \" much however. If like most people, you use reflection for editor functionality, not a physics simulation. Performance in most cases is not critical.\"), mdx(\"p\", null, \"Here\\u2019s a more complete example of dynamically calling functions with the runtime library.\"), mdx(\"script\", {\n    src: \"https://gist.github.com/AustinBrunkhorst/402f85b21539250532da613ec02bd00f.js\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;"},"site":{"siteMetadata":{"title":"Austin Brunkhorst"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"b0bfa1d0-ce5c-543d-abfc-9a88cdd60bfb","excerpt":"Back in September ( 2015 ), I did a little write-up on my experiences and approach to building a complete reflection pipeline in C++. At…","slug":"/cpp-reflection-part-1","title":"C++ Reflection","date":"June 16, 2019","siteTitle":"Austin Brunkhorst","socialLinks":[{"name":"twitter","url":"https://twitter.com/ABrunkhorst"},{"name":"github","url":"https://github.com/AustinBrunkhorst"},{"name":"linkedin","url":"https://www.linkedin.com/in/austinbrunkhorst/"}],"previous":null,"next":null}}}